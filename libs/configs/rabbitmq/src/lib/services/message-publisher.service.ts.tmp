import { Inject, Injectable, Logger } from '@nestjs/common';
import { ClientProxy } from '@nestjs/microservices';
import { Observable, firstValueFrom, timeout, retry, catchError, throwError } from 'rxjs';

import { RABBITMQ_CLIENT, RABBITMQ_OPTIONS, DEFAULT_RETRY_CONFIG } from '../rabbitmq.constants';
import { RabbitMQModuleOptions, PublishOptions, RetryPolicy } from '../interfaces';

/**
 * Message publisher service for advanced publishing operations.
 * 
 * This service provides:
 * - Advanced message publishing with custom options
 * - Batch message publishing
 * - Priority message handling
 * - Delayed message publishing
 * - Message routing and filtering
 * 
 * @example
 * ```typescript
 * // Inject the service
 * constructor(private readonly publisher: MessagePublisherService) {}
 * 
 * // Publish with custom options
 * await this.publisher.publish('user.notification', data, {
 *   priority: 10,
 *   persistent: true,
 *   expiration: 60000,
 * });
 * 
 * // Batch publish
 * await this.publisher.publishBatch([
 *   { pattern: 'user.create', data: user1 },
 *   { pattern: 'user.create', data: user2 },
 * ]);
 * ```
 */
@Injectable()
export class MessagePublisherService {
  private readonly logger = new Logger(MessagePublisherService.name);

  constructor(
    @Inject(RABBITMQ_CLIENT) private readonly client: ClientProxy,
    @Inject(RABBITMQ_OPTIONS) private readonly options: RabbitMQModuleOptions,
  ) {
    this.logger.log('Message Publisher Service initialized');
  }

  /**
   * Publishes a message with advanced options.
   * 
   * @param pattern - Message pattern or routing key
   * @param data - Message payload
   * @param options - Publishing options
   * @returns Promise resolving when message is published
   */
  async publish<T = unknown>(
    pattern: string,
    data: T,
    options?: PublishOptions,
  ): Promise<void> {
    try {
      const publishOptions = this.buildPublishOptions(options);
      
      this.logger.debug(
        `Publishing message to pattern: ${pattern}`,
        { options: publishOptions },
      );

      // Use emit for fire-and-forget publishing
      this.client.emit(pattern, data);
      
      this.logger.debug(`Message published successfully to pattern: ${pattern}`);
    } catch (error) {
      this.logger.error(
        `Failed to publish message to pattern ${pattern}:`,
        error instanceof Error ? error.message : error,
      );
      throw error;
    }
  }

  /**
   * Publishes a message and waits for acknowledgment.
   * 
   * @param pattern - Message pattern or routing key
   * @param data - Message payload
   * @param options - Publishing options
   * @returns Promise resolving to the response
   */
  async publishAndWait<TResult = unknown, TInput = unknown>(
    pattern: string,
    data: TInput,
    options?: PublishOptions,
  ): Promise<TResult> {
    try {
      const publishOptions = this.buildPublishOptions(options);
      const retryPolicy = this.options.globalRetryPolicy || DEFAULT_RETRY_CONFIG;
      
      this.logger.debug(
        `Publishing message with wait to pattern: ${pattern}`,
        { options: publishOptions },
      );

      const response$ = this.client.send<TResult, TInput>(pattern, data).pipe(
        timeout(options?.timeout || 30000),
        retry(retryPolicy.maxRetries || 3),
        catchError((error) => {
          this.logger.error(
            `Failed to publish and wait for pattern ${pattern}:`,
            error.message,
          );
          return throwError(() => error);
        }),
      );

      const result = await firstValueFrom(response$);
      this.logger.debug(`Received response for pattern: ${pattern}`);
      return result;
    } catch (error) {
      this.logger.error(
        `Error in publishAndWait for pattern ${pattern}:`,
        error instanceof Error ? error.message : error,
      );
      throw error;
    }
  }

  /**
   * Publishes multiple messages in a batch.
   * 
   * @param messages - Array of messages to publish
   * @param options - Global options for all messages
   * @returns Promise resolving when all messages are published
   */
  async publishBatch<T = unknown>(
    messages: Array<{
      pattern: string;
      data: T;
      options?: PublishOptions;
    }>,
    options?: Partial<PublishOptions>,
  ): Promise<void> {
    try {
      this.logger.debug(`Publishing batch of ${messages.length} messages`);

      const publishPromises = messages.map(({ pattern, data, options: msgOptions }) =>
        this.publish(pattern, data, { ...options, ...msgOptions }),
      );

      await Promise.all(publishPromises);
      this.logger.debug(`Successfully published batch of ${messages.length} messages`);
    } catch (error) {
      this.logger.error(
        'Failed to publish message batch:',
        error instanceof Error ? error.message : error,
      );
      throw error;
    }
  }

  /**
   * Publishes a priority message.
   * 
   * @param pattern - Message pattern or routing key
   * @param data - Message payload
   * @param priority - Message priority (0-255, higher is more priority)
   * @param options - Additional publishing options
   * @returns Promise resolving when message is published
   */
  async publishPriority<T = unknown>(
    pattern: string,
    data: T,
    priority: number,
    options?: Omit<PublishOptions, 'priority'>,
  ): Promise<void> {
    return this.publish(pattern, data, { ...options, priority });
  }

  /**
   * Publishes a message with expiration.
   * 
   * @param pattern - Message pattern or routing key
   * @param data - Message payload
   * @param expiration - Message expiration in milliseconds
   * @param options - Additional publishing options
   * @returns Promise resolving when message is published
   */
  async publishWithExpiration<T = unknown>(
    pattern: string,
    data: T,
    expiration: number,
    options?: Omit<PublishOptions, 'expiration'>,
  ): Promise<void> {
    return this.publish(pattern, data, { ...options, expiration });
  }

  /**
   * Publishes a message as a stream and returns an Observable.
   * 
   * @param pattern - Message pattern or routing key
   * @param data - Message payload
   * @param options - Publishing options
   * @returns Observable of responses
   */
  publishStream<TResult = unknown, TInput = unknown>(
    pattern: string,
    data: TInput,
    options?: PublishOptions,
  ): Observable<TResult> {
    try {
      const publishOptions = this.buildPublishOptions(options);
      
      this.logger.debug(
        `Publishing stream message to pattern: ${pattern}`,
        { options: publishOptions },
      );

      return this.client.send<TResult, TInput>(pattern, data).pipe(
        timeout(options?.timeout || 30000),
        catchError((error) => {
          this.logger.error(
            `Failed to publish stream message to pattern ${pattern}:`,
            error.message,
          );
          return throwError(() => error);
        }),
      );
    } catch (error) {
      this.logger.error(
        `Error in publishStream for pattern ${pattern}:`,
        error instanceof Error ? error.message : error,
      );
      throw error;
    }
  }

  /**
   * Builds publish options with defaults.
   * 
   * @param options - User provided options
   * @returns Complete publish options
   */
  private buildPublishOptions(options?: PublishOptions): PublishOptions {
    return {
      persistent: true,
      priority: 0,
      ...options,
    };
  }

  /**
   * Gets publisher statistics and information.
   * 
   * @returns Publisher information
   */
  getPublisherInfo(): {
    defaultQueue?: string;
    globalRetryPolicy?: RetryPolicy;
    environment?: string;
  } {
    return {
      defaultQueue: this.options.defaultQueue,
      globalRetryPolicy: this.options.globalRetryPolicy,
      environment: this.options.environment,
    };
  }
}