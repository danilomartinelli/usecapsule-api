# Capsule Rust SDK

SDK oficial da plataforma Capsule para aplicações Rust.

## Características

### Versões Suportadas
- Rust 1.70+
- Cargo package manager
- Async/await support (tokio)
- WASM compatibility

### Framework Integrations
- Axum middleware
- Actix-web extractors
- Warp filters
- Rocket fairings

## Funcionalidades Planejadas

### Client Base
```rust
use capsule::{Client, Config};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new(Config {
        api_key: std::env::var("CAPSULE_API_KEY")?,
        base_url: "https://api.usecapsule.com".to_string(),
        timeout: std::time::Duration::from_secs(30),
    });
    
    Ok(())
}
```

### Deploy Management
```rust
use capsule::{DeploymentOptions, DeploymentStatus};
use std::collections::HashMap;

// Deploy simples
let mut env = HashMap::new();
env.insert("RUST_LOG".to_string(), "info".to_string());

let deployment = client.deployments().create(DeploymentOptions {
    name: "rust-app".to_string(),
    image: "rust:1.75-alpine".to_string(),
    port: Some(8080),
    env: Some(env),
    replicas: Some(1),
}).await?;

// Aguardar deploy
client.deployments()
    .wait_for_ready(&deployment.id, Duration::from_secs(300))
    .await?;
```

### Streaming Logs
```rust
use futures_util::StreamExt;

// Stream de logs
let log_stream = client.deployments()
    .logs(&deployment_id, LogOptions {
        follow: true,
        tail: Some(100),
    })
    .await?;

tokio::pin!(log_stream);
while let Some(line) = log_stream.next().await {
    println!("{}", line?);
}
```

### Axum Middleware
```rust
use axum::{Extension, Router};
use capsule::integrations::axum::CapsuleLayer;

let app = Router::new()
    .layer(CapsuleLayer::new(
        std::env::var("CAPSULE_API_KEY")?,
        CapsuleConfig {
            auto_log: true,
            metrics: true,
        }
    ));
```

## Estrutura Planejada

```
tools/sdk/rust/
├── src/
│   ├── lib.rs
│   ├── client.rs
│   ├── resources/
│   │   ├── deployments.rs
│   │   ├── projects.rs
│   │   └── environments.rs
│   ├── integrations/
│   │   ├── axum/
│   │   ├── actix/
│   │   └── warp/
│   ├── types.rs
│   └── error.rs
├── tests/
├── examples/
│   ├── basic_deploy.rs
│   ├── axum_server.rs
│   └── async_example.rs
├── Cargo.toml
└── README.md
```

### Type Safety Completo
```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct DeploymentOptions {
    pub name: String,
    pub image: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<u16>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub env: Option<std::collections::HashMap<String, String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replicas: Option<u32>,
}

#[derive(Debug, Deserialize)]
pub struct Deployment {
    pub id: String,
    pub name: String,
    pub status: DeploymentStatus,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DeploymentStatus {
    Pending,
    Running,
    Failed,
    Stopped,
}
```

### Error Handling Idiomático
```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CapsuleError {
    #[error("Authentication failed: {0}")]
    Authentication(String),
    
    #[error("Validation error: {message}")]
    Validation { message: String },
    
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("JSON parsing error: {0}")]
    Json(#[from] serde_json::Error),
}

pub type Result<T> = std::result::Result<T, CapsuleError>;
```

### Actix-web Integration
```rust
use actix_web::{web, App, HttpServer, Result};
use capsule::integrations::actix::CapsuleExtractor;

async fn deploy_handler(
    capsule: CapsuleExtractor,
    payload: web::Json<DeploymentOptions>
) -> Result<web::Json<Deployment>> {
    let deployment = capsule.deployments()
        .create(payload.into_inner())
        .await
        .map_err(|e| actix_web::error::ErrorInternalServerError(e))?;
    
    Ok(web::Json(deployment))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .app_data(CapsuleExtractor::from_env())
            .route("/deploy", web::post().to(deploy_handler))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
```

### WASM Compatibility
```rust
#[cfg(target_arch = "wasm32")]
mod wasm {
    use wasm_bindgen::prelude::*;
    use super::*;

    #[wasm_bindgen]
    pub struct CapsuleClient {
        inner: Client,
    }

    #[wasm_bindgen]
    impl CapsuleClient {
        #[wasm_bindgen(constructor)]
        pub fn new(api_key: String) -> Self {
            Self {
                inner: Client::new(Config {
                    api_key,
                    base_url: "https://api.usecapsule.com".to_string(),
                    timeout: Duration::from_secs(30),
                })
            }
        }
    }
}
```

### Performance e Concorrência
```rust
use tokio::sync::RwLock;
use std::sync::Arc;

pub struct Client {
    http_client: reqwest::Client,
    rate_limiter: Arc<RwLock<RateLimiter>>,
}

impl Client {
    pub async fn with_rate_limiting(&self) -> Result<()> {
        let mut limiter = self.rate_limiter.write().await;
        limiter.acquire().await?;
        Ok(())
    }
}
```